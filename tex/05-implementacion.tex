% Capítulo 5: Implementación
% ---------------------------------------------------------------------------------------------------------------
\chapter{Implementación}
\label{ch:implem}

En este capítulo se realizará la implementación de las herramientas más destacadas en base a los análisis previos. La integración de estas herramientas se llevarán a cabo en un entorno real de desarrollo, específicamente en la aplicación \textbf{Seahorse} \cite{55}. Esta aplicación está enfocada en la creación colaborativa y privada de albumes de fotos y vídeos. En la figura \ref{fig:Fig20} es posible ver algunas de las pantallas de esta aplicación.
\begin{figure}[h!]
\centering
      \includegraphics[width=15cm]{Imagenes/seahorse_screenshots}
\caption{Vistas de la aplicación Seahorse. Fuente: Elaboración Propia}
\label{fig:Fig20}
\end{figure}

Las herramientas implementadas son las que más se ajustaban a las necesidades y a los recursos con los que cuenta Seahorse, por lo que fácilmente este conjunto de herramientas puede diferir en relación a las implementaciones que otros desarrolladores harían en sus aplicaciones.

\section{Implementación de Herramientas de Testing}
\subsection{Robolectric}
Para la implementación de Robolectric es necesario seguir los pasos de instalación que se detallan en su sitio oficial \cite{56}. En Seahorse se usa Gradle para manejar las dependencias, por lo que es necesario agregar esta línea a \textit{build.gradle}:
\begin{lstlisting}
dependencies {
  ...
  androidTestCompile 'org.robolectric:robolectric:2.3' 
}
\end{lstlisting}
Para más detalles sobre como realizar la instalación con Android Studio, se puede seguir el tutorial que presenta en su blog \cite{57} uno de los desarrolladores de Google.

El test que se llevó a cabo consiste en verificar que el flujo inicial de la aplicación se realice de forma correcta. Básicamente se testea que el usuario pueda acceder sin problemas a las pantallas de login y de registro. En la figura \ref{fig:Fig21} se muestra el flujo que se someterá a prueba, el cual consta de 3 tareas básicas:
\begin{itemize}
\item Abrir Seahorse.

\item Presionar el botón que dice \textit{Log In} y mostrar un menu con opciones.

\item Presionar el botón que dice \textit{Sign in with email} y llevar al usuario a la vista de Login.
\end{itemize}

\begin{figure}[h!]
\centering
      \includegraphics[width=15cm]{Imagenes/seahorse_testing_flujo_login}
\caption{Flujo para acceder a la pantalla de Login en la aplicación Seahorse. En la primera imagen se presiona el botón \textit{Log In}, lo cual abre el menu de la segunda imagen, y se presiona el botón \textit{Sign in with email}, lo cual abre la vista de Login de la última imagen. Fuente: Elaboración Propia}
\label{fig:Fig21}
\end{figure}

Dentro del proyecto de Seahorse, se creó una clase en el paquete \textit{co.seahorse.android.test}. En este caso la \textit{Activity} testeada es SeahorseStartActivity y el nombre de la clase que se encarga de realizar el test es SeahorseStartActivityTest. 
\begin{lstlisting}
@RunWith(RobolectricGradleTestRunner.class)
public class SeahorseStartActivityTest {
    private SeahorseStartActivity activity;
    private Button buttonLogin;
    private Button buttonRegister;
    private Button buttonSign;
    @Before
    public void setup() throws Exception {
        activity = Robolectric.buildActivity(SeahorseStartActivity.class).create().start().get();
        buttonLogin = (Button) activity.findViewById(R.id.buttonLogInAccount);
        buttonRegister = (Button) activity.findViewById(R.id.buttonRegisterAccount);
        buttonSign = (Button) activity.findViewById(R.id.buttonSignIn);
    }
\end{lstlisting}
El método \textit{setup()} se encarga de crear la referencia a la \textit{Activity} que se desea testear y obtener los botones que también serán testeados.

Es una buena práctica verificar que ninguno de los elementos obtenidos en el método anterior esten vacíos, por lo que el primer test se encargará de eso:
\begin{lstlisting}
    @Test
    public void shouldNotBeNull() {
        assertNotNull(activity);
        assertNotNull(buttonLogin);
        assertNotNull(buttonRegister);
        assertNotNull(buttonSign);
    }
\end{lstlisting}

Por último se realiza el test del flujo que lleva a la pantalla de Login:
\begin{lstlisting}
    @Test
    public void buttonClickShouldStarLoginActivity() throws Exception {
        buttonLogin.performClick();
        buttonSign.performClick();
        Intent intent = Robolectric.shadowOf(activity).peekNextStartedActivity();
        assertEquals(LoginActivity.class.getCanonicalName(), intent.getComponent().getClassName());
    }
    \end{lstlisting}
A través del método \textit{performClick()} es posible simular la lógica del boton, tal como si un usuario real lo hubiese presionado. Esto se realiza dos veces, ya que se tienen que simular dos clicks a dos botones distintos. El último de los click es el que abre la pantalla de Login por lo que se verifica que la \textit{Activity} que se inició corresponda a \textit{LoginActivity}.

Al ejecutar los tests, se genera un reporte en HTML, que se ubica en la raiz del proyecto, en \textit{./build/test-report/index.html}. En este reporte se detallan la cantidad total de test ejecutados y el tiempo que se demoraron, como también los test que fallaron y la razón.

\subsection{Robotium}
Se implementó Robotium, en vez de Espresso, principalmente porque existe mayor documentación y porque cuenta con soporte para gradle de forma oficial, por lo que la integración con Android Studio es menos compleja. Además lleva más tiempo de desarrollo y es una herramienta bastante madura.

Para la implementación es necesario agregar la siguiente dependencia al archivo gradle del proyecto:
\begin{lstlisting}
dependencies {
  ...
  androidTestCompile 'com.jayway.android.robotium:robotium-solo:4.3'
}
\end{lstlisting}
El test que se realizó es similar al realizado a través de Robolectric, aunque ahora de forma instrumental, es decir ejecutándolo directamente en el dispositivo. Para ello se ha creado la clase RobotiumTest, la cual consiste en lo siguiente:
\begin{lstlisting}
public class RobotiumTest extends ActivityInstrumentationTestCase2 {
    private Solo solo;

    public RobotiumTest() {
        super(SeahorseStartActivity.class);
    }

    public void setUp() throws Exception {
        super.setUp();
        solo = new Solo(getInstrumentation(), getActivity());
    }

    public void testRobotium()  throws Exception {

        solo.assertCurrentActivity("SeahorseStartActivity Never Loaded", SeahorseStartActivity.class);
        solo.clickOnText(getActivity().getString(R.string.LOGIN));
        solo.waitForText(getActivity().getString(R.string.SIGN_IN_WITH_EMAIL));
        solo.clickOnText(getActivity().getString(R.string.SIGN_IN_WITH_EMAIL));
        solo.assertCurrentActivity("LoginActivity Never Loaded", LoginActivity.class);
        solo.takeScreenshot();
    }
\end{lstlisting}
La clase \textit{Solo} es la principal para desarrollar tests con Robotium. En el método \textit{setup()} se crea una referencia de \textit{Solo} a partir de la \textit{Activity} actual.

En el método \textit{testRobotium()} es donde se lleva a cabo el test. Como se puede ver, todo se realiza a través de la clase \textit{Solo}. Con ella se corrobora en un principio si la \textit{Activity} actual corresponde a \textit{SeahorseStartActivity}, luego se hace un click en el texto que dice ``Log In''. Debido a que existe una animación para mostrar el menu, se recurre al método \textit{waitForText} para esperar que la animación termine y luego presionar este botón. Finalmente se presionar el texto ``Sign in with email'' y se comprueba que la nueva \textit{Activity} actual corresponde a \textit{LoginActivity}. Todo este proceso, al ser ejecutado en un dispositivo real, demora 5.69 segundos, lo cuál no es mucho, pero si se toma en cuenta que dentro de un proyecto se pueden tener una gran cantidad de tests, entonces si puede decirse que es un tiempo considerable. Debido a esto, es importante decidir de forma sabia, que cosas son realmente necesarias testear de forma instrumental.

%\subsection{Espresso} 
%Para la implementación de Espresso, uno de los mayores problemas es que no cuenta oficialmente con soporte para gradle, por lo que se utilizó la biblioteca Double Espresso \cite{58}, que no cambia en nada el código original y simplemente le agrega este soporte. Las dependencias agregadas a gradle son:
%\begin{lstlisting}
%dependencies {
%  ...
%  androidTestCompile 'com.jakewharton.espresso:espresso:1.1-r3'
%  androidTestCompile 'com.jakewharton.espresso:espresso-support-v4:1.1-r3'
%}
%\end{lstlisting}
%A diferencia de Robolectric, Espresso se especializa en los test relacionados con la interfaz de la aplicación. 
\subsection{Spoon}
....
\subsection{uiautomatorviewer}
Esta es una herramienta de apoyo, que puede servir para personas que están involucradas en el desarrollo de un proyecto móbil, pero que no son desarrolladores. Se puede obtener información muy detallada sobre el árbol jerárquico de vistas y de cada uno de sus elementos. A través de esta información es posible planear diferentes tipos de tests.\\

En la figura \ref{fig:Fig19} se puede apreciar que a la izquierda se tiene una screenshot de la aplicación, y al lado derecho se muestra el árbol jerárquico de vistas de la aplicación. Además el desarrollador puede presionar sobre los elementos del screenshot y obtener información sobre esa vista, tales como la clase, si la vista tiene habilitado el scroll, si la vista se le puede hacer click, entre otras cosas.

\begin{figure}[h!]
\centering
      \includegraphics[width=15cm]{Imagenes/testing_uiautomatorview}
\caption{Vista de la herramienta uiautomatorviewer en una aplicación. Fuente: Elaboración Propia}
\label{fig:Fig19}
\end{figure}

\subsection{Monkey}
Esta herramienta es principalmente usada para realizar casos de testing de estrés. Esto quiere decir que la aplicación es deliberadamente sometida a una gran cantidad de eventos para determinar la estabilidad y el manejo de errores. Los eventos generados consistirán en acciones que podría realizar un usuario normal, como clicks, toques, o gestos, pero un una cantidad muy elevada.\\

Por ejemplo, el siguiente comando enviará 2000 eventos aleatorios a la aplicación con el nombre de paquete co.seahorse.android:\\

\begin{lstlisting}
adb shell monkey -p co.seahorse.android -v 2000
\end{lstlisting}

\newpage
\section{Implementación de Herramientas de Distribución}
\subsection{HockeyApp}
Antes de HockeyApp, en Seahorse se usaba TestFlight \cite{59}, pero ellos dejaron de dar soporte a Android en Marzo de este año \cite{60} ya que fueron comprados por Apple, por lo que fue necesario migrar a otro servicio. HockeyApp cumplía con prácticamente todas las necesidades que entregaba TestFlight, siendo una de ellas el soporte para  aplicaciones tanto Android como iOS. 

Actualmente se pagan 10 dólares por el servicio, de forma mensual, lo que corresponde al plan más económico ofrecido por HockeyApp, que permite tener hasta 5 aplicaciones distintas en la plataforma, con una cantidad ilimitada de usuarios.

Para distribuir las versiones, la primera vez es necesario agregar información básica como el nombre de la aplicación y el nombre del paquete. Luego se sube el APK de la aplicación y se invita a las personas que se deseen a esta versión. Cada vez que se sube una versión nueva, es posible notificar a los usuarios que ya cuentan con una versión anterior para que la actualicen. Además, es posible invitar a nuevas personas en cualquier momento. 

El desarrollador cuenta con información básica de los testers, como el modelo y dispositivo con el que cuenta, y también es posible saber si es que ya tienen la última versión.

En la figura \ref{fig:Fig22} se puede ver la vista que tiene el desarrollador sobre una versión beta de Seahorse. La acciones más frecuente están en la parte superior, teniendo opciones para subir una nueva versión de la misma aplicación, invitar más usuarios o cambiar información básica de la aplicación. En la parte inferior es posible ver la lista de todas las últimas versiones que se han enviado de esa aplicación, con información como el peso de la aplicación, cuando fue subida esa actualización y la cantidad de descargas que se han tenido. En Seahorse no está implementado el SDK que entrega reporte de crashes, ya que se usa otra herramienta más avanzada para ello. Por último, sobre las acciones más frecuente hay un menu que ofrece la opción de ver todas las versiones que ha tenido la beta, la lista de usuarios que tienen acceso a la beta y el posible feedback que han entregado cada uno de ellos.
\begin{figure}
\centering
      \includegraphics[width=15cm]{Imagenes/distribution_hockeyapp}
\caption{Vista de una aplicación beta de Seahorse en HockeyApp. Fuente: Elaboración Propia}
\label{fig:Fig22}
\end{figure}
%Para su implementación es necesario crearse una cuenta dentro del sitio ....crear la app, subir apk, invitar gente al apk, dps de cada actualizacion aparece la lista de personas para notificarla, en la misma plataforma se puede ver el feedback que dan los usuarios.

\subsection{UserTesting}
UserTesting es la plataforma usada en Seahorse para lanzar versiones beta y recibir feedback de usuarios de prueba a través de videos. Esta herramienta es usada por grandes empresas como Google, Apple, Microsoft, Twitter, Facebook y  Yahoo, para la distribución y testing de versiones de prueba de sitios web, aplicaciones de escritorios y aplicaciones móbiles. El servicio funciona a través de la compra de créditos, en donde por ejemplo, 1000 dólares otorgan al desarrollador 20 créditos. Cada uno de estos créditos sirve para realizar un test con un usuario, aunque también es posible realizar un mismo test a más de un usuario, pero en definitiva, por cada usuario que realice un test, un crédito es consumido. Debido al elevado valor de cada crédito, el desarrollador debe tener claro que es lo que quiere testear dentro de la aplicación y cuáles son los resultados que espera.

En Seahorse se usa UserTesting al momento de implementar nuevas características en la aplicación, para ver temas de usabilidad y para corroborar que el usuario entiende de forma intuitiva lo implementado. Además sirve para encontrar posibles errores en otros dispositivos, ya que debido a la fragmentación existente en Android es prácticamente imposible saber como una aplicación se ve en cada uno de los dispositivos existentes.

Para la creación de un test los pasos son los siguientes:
\begin{itemize}
\item Seleccionar si la aplicación móvil es de Android o iOS

\item Agregar instrucciones de como instalar la aplicación y una breve descripción para que el usuario tenga una idea de lo que va a testear.

\item Agregar una serie de tareas que el usuario debe ir realizando. También se pueden incluir preguntas durante el proceso, para saber si la tarea solicitada fue complicada, o simplemente para saber que piensa el usuario sobre esa tarea.

\item Agregar un cuestionario final con preguntas más generales sobre la aplicación y el proceso completo.

\item Por último es posible solicitar algunas características demográficas como el rango de edad, el país, el género, la experiencia con aplicaciones móviles, y otras restricciones como versión de Android mayor a 4.0, o que el usuario cuente con fotos en su galeria.
\end{itemize}

Cuando en Seahorse se agregó el registro de usuarios a través de Facebook y de Google+, se llevo a cabo la distribución y testing a través de esta plataforma. Esto permitió corroborar que esta nueva característica, al igual que otras, funcionaban correctamente. Fue necesario hacer en total unos 8 tests, ya que en cada iteración se usaban 4 créditos, dos para comprobar que el registro a través de Facebook funcionaba bien, y otros 2 para comprobar lo mismo, pero a través de Google+. Los tests a través de Facebook funcionaron correctamente, pero con Google+ existieron dificultades, ya que uno de los usuarios no pudo realizar el registro. Debido a esto, después de realizar algunas correcciones se llevaron a cabo nuevos tests, con los que se obtuvieron resultados positivos. Tal como se mencionó antes, es necesario aprovechar cada uno de los tests, por lo que además de testear el registro de los usuarios, también se solicitaron otras tareas, como importar albums de otras plataformas, sincronizar la cámara del dispositivo con Seahorse, invitar a otros usuarios a la aplicación, entre otras.

Cada uno de los videos entregó información valiosa sobre la usabilidad dentro de la aplicación, y permitió verificar la UI en 8 dispositivos distintos, algunos con una pantalla muy pequeña. Los videos duran entre 15 y 20 minutos, y el usuario va relatando todo el proceso, desde la instalación de la aplicación, hasta el cuestionario final.
\newpage
\section{Implementación de Herramientas de Reportes de Crashes}
\subsection{Crittercism}
Crittercism a sido la plataforma escogida para la recepción de crashes, principalmente por el nivel de detalle presente en sus reportes. Además el valor que se paga mensualmente es bastante accesible para cualquier empresa del rubro. Actualmente dentro de Seahorse, se pagan 24 dólares por este servicio, lo que da acceso a reportes muy detallados que permiten reparar de forma rápida cada crash. 

Crittercism ha permitido disminuir la tasa de crashes y ofrece variadas estadísticas para ver información como los dispositivos en los que existen más crashes, el sistema operaritivo en que ocurren más crashes o la versión en la que ocurrieron más crashes. Después del lanzamiento de cada actualización se reparan una gran cantidad de bugs, pero aparecen nuevos crashes, lo que es inherente al proceso de desarrollo de software, ya que se incluye nuevo código, pero con esta herramienta es posible contar con información muy detallada, facilitando en gran medida la tarea de los desarrolladores.

La instalación es bastante simple \cite{31}. Existen dos formas en que se puede incluir el SDK de Crittercism, la primera es descargándolo desde el sitio web e incluyendolo al proyecto, la segunda es agregando la dependencia al archivo gradle del proyecto de la siguiente forma:
\begin{lstlisting}
compile 'com.crittercism:crittercism-android-agent:+'
\end{lstlisting}
Luego se deben agregar los siguientes permisos en el archivo Android Manifest del proyecto: 
\begin{lstlisting}
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.READ_LOGS"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
<uses-permission android:name="android.permission.GET_TASKS"/>
\end{lstlisting}
El primer permiso es necesario para poder acceder a Internet y poder enviar los reportes. El segundo es necesario para poder obtener la información de los stack trace del usuario, y ahi saber en que línea de código ha ocurrido el error. El tercero es para obtener información sobre el estado de la red, por ejemplo, para saber si el usuario está conectado a Wi-Fi o a través de un carrier. El último permiso sirve para acceder a la información de las últimas dos \textit{Activities} ejecutadas, lo que permite saber en que pantalla ocurrió el crash.

Una vez que los permisos ya están entregados, se debe inicializar Crittercism. Esto se hace únicamente una vez por aplicación, por lo que se debe hacer en la primera \textit{Activity} que se ejecuta dentro de la aplicación. Para iniciar Crittercism se escribe la siguiente línea en el onCreate:
\begin{lstlisting}
Crittercism.initialize(getApplicationContext(), "CRITTERCISM_APP_ID");
\end{lstlisting}

Ahora ya están implementadas las características básicas, y comenzarán a llegar los reportes al sitio web de Crittercism. También es posible agregar a otros desarrolladores al servicio, para que tengan acceso a la misma información y que todo el equipo reciba los reportes de crashes al correo.

La documentación con la que cuenta es excelente para entender los alcances y todas las cosas que se pueden hacer a través de Crittercism. Por ejemplo, es posible recibir las excepciones que ocurren dentro de la aplicación. Esto se realiza agregando las siguientes líneas en la excepción que se desea recibir:
\begin{lstlisting}
try {
    throw new Exception("Aquí ocurre una excepción");
} catch (Exception exception) {
    //De esta forma se captura y se envía a Crittercism
    Crittercism.logHandledException(exception);
}
\end{lstlisting}

A través de los gráficos de la figura \ref{fig:Fig23} es posible dimensionar la utilidad de contar con una herramienta como Crittercism. El gráfico de la izquierda indica la cantidad de reportes de crashes recibidos por distintas versiones de la aplicación durante el mes de Enero. El gráfico de la derecha indica la cantidad de usuarios que han sido afectados por al menos un crash durante ese mismo periodo. A través de estos gráficos es posible ver que la versión 0.8.8 de color amarillo, fue lanzada el día 9 de Enero y rápidamente comenzaron a llegar una gran cantidad de reportes de crashes, alcanzando la cifra de 173 crashes y afectando a más de 100 usuarios. Debido a ello, al día siguiente se lanzó la versión 0.8.8.1 de color verde, la cuál se encargó de arreglar el error introducido en la versión previa y reduciendo este número en gran medida, con sólo 35 crashes y afectando a 20 usuarios. Si no se hubiera contado con una herramienta que entregue los reportes de crashes en tiempo real, probablemente habrían transcurrido más días con el mismo problema, afectando a muchos más usuarios. 
\begin{figure}
\centering
      \includegraphics[width=16cm]{Imagenes/crash_report_crittercism_graphs}
\caption{Gráficos que entrega Crittercism sobre cantidad de crashes y usuarios afectados en un periodo de un mes. Fuente: Elaboración Propia}
\label{fig:Fig23}
\end{figure}

\subsection{Google Analytics}
Google Analytics ha sido implementada, aunque no por sus reportes de crashes, sino que para el tracking de eventos y performance.
Para su implementación es necesario descarga desde el sitio de Google Analytics \cite{33} la versión 3 de su SDK. Una vez descargado el SDK, es necesario incluirlo al proyecto y dar los siguientes permisos en el archivo Android Manifest:
\begin{lstlisting}
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
\end{lstlisting}
Para implementarlo a través de código es necesario agregar estas líneas en cada una de las \textit{Activities} de las cuáles se desee obtener información:
\begin{lstlisting}
@Override
  public void onStart() {
    super.onStart();
    ... // El resto del código de onStart()
    EasyTracker.getInstance(this).activityStart(this);  // Agregar este método
  }

  @Override
  public void onStop() {
    super.onStop();
    ... // El resto del código de onStop()
    EasyTracker.getInstance(this).activityStop(this);  // Agregar este método
  }
\end{lstlisting}
% ---------------------------------------------------------------------------------------------------------------