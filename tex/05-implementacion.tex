% Capítulo 5: Implementación
% ---------------------------------------------------------------------------------------------------------------
\chapter{Implementación}
\label{ch:implem}

En este capítulo se realizará la implementación de las herramientas más destacadas en base a los análisis previos. La integración de estas herramientas se llevarán a cabo en un entorno real de desarrollo, específicamente en la aplicación \textbf{Seahorse} \cite{55}. Esta aplicación está enfocada en la creación colaborativa y privada de albumes de fotos y vídeos. En la figura \ref{fig:Fig20} es posible ver algunas de las pantallas de esta aplicación.
\begin{figure}[h!]
\centering
      \includegraphics[width=15cm]{Imagenes/seahorse_screenshots}
\caption{Vistas de la aplicación Seahorse. Fuente: Elaboración Propia}
\label{fig:Fig20}
\end{figure}

Las herramientas implementadas son las que más se ajustaban a las necesidades y a los recursos con los que cuenta Seahorse, por lo que fácilmente este conjunto de herramientas puede diferir en relación a las implementaciones que otros desarrolladores harían en sus aplicaciones.

\section{Implementación de Herramientas de Testing}
\subsection{Robolectric}
Para la implementación de Robolectric es necesario seguir los pasos de instalación que se detallan en su sitio oficial \cite{56}. En Seahorse se usa Gradle \cite{61} para automatizar la construcción y compilación el proyecto, aunque también es posible usar Ant \cite{62} o Maven \cite{63}. Para agregar Robolectric a un proyecto configurado con Gradle es necesario agregar esta línea al archivo \textit{build.gradle} del proyecto:
\begin{lstlisting}
dependencies {
  ...
  androidTestCompile 'org.robolectric:robolectric:2.3' 
}
\end{lstlisting}
Para más detalles sobre cómo realizar la instalación con Android Studio, se puede seguir el tutorial que presenta en su blog \cite{57} uno de los desarrolladores de Google.

El test que se llevó a cabo consiste en verificar que el flujo inicial de la aplicación se realice de forma correcta. Básicamente se testea que el usuario pueda acceder sin problemas a las pantallas de login y de registro. En la figura \ref{fig:Fig21} se muestra el flujo que se someterá a prueba, el cual consta de 3 tareas básicas:
\begin{itemize}
\item Abrir Seahorse.

\item Presionar el botón que dice \textit{Log In} y mostrar un menú con opciones.

\item Presionar el botón que dice \textit{Sign in with email} y llevar al usuario a la vista de Login.
\end{itemize}

\begin{figure}[h!]
\centering
      \includegraphics[width=15cm]{Imagenes/seahorse_testing_flujo_login}
\caption{Flujo para acceder a la pantalla de Login en la aplicación Seahorse. En la primera imagen se presiona el botón \textit{Log In}, lo cual abre el menu de la segunda imagen, y se presiona el botón \textit{Sign in with email}, lo que abre la vista de Login de la última imagen. Fuente: Elaboración Propia}
\label{fig:Fig21}
\end{figure}

Dentro del proyecto de Seahorse, se creó una clase en el paquete \textit{co.seahorse.android.test}. En este caso la \textit{Activity} testeada es SeahorseStartActivity y el nombre de la clase que se encarga de realizar el test es SeahorseStartActivityTest. 
\begin{lstlisting}
@RunWith(RobolectricGradleTestRunner.class)
public class SeahorseStartActivityTest {
    private SeahorseStartActivity activity;
    private Button buttonLogin;
    private Button buttonRegister;
    private Button buttonSign;
    @Before
    public void setup() throws Exception {
        activity = Robolectric.buildActivity(SeahorseStartActivity.class).create().
            start().get();
        buttonLogin = (Button) activity.findViewById(R.id.buttonLogInAccount);
        buttonRegister = (Button) activity.findViewById(R.id.buttonRegisterAccount);
        buttonSign = (Button) activity.findViewById(R.id.buttonSignIn);
    }
\end{lstlisting}
El método \textit{setup()} se encarga de crear la referencia a la \textit{Activity} que se desea testear y obtener los botones que también serán testeados.

Es una buena práctica verificar que ninguno de los elementos obtenidos en el método anterior estén vacíos, por lo que el primer test se encargará de eso:
\begin{lstlisting}
    @Test
    public void shouldNotBeNull() {
        assertNotNull(activity);
        assertNotNull(buttonLogin);
        assertNotNull(buttonRegister);
        assertNotNull(buttonSign);
    }
\end{lstlisting}

Por último se realiza el test del flujo que lleva a la pantalla de Login:
\begin{lstlisting}
    @Test
    public void buttonClickShouldStarLoginActivity() throws Exception {
        buttonLogin.performClick();
        buttonSign.performClick();
        Intent intent = Robolectric.shadowOf(activity).peekNextStartedActivity();
        assertEquals(LoginActivity.class.getCanonicalName(), intent.getComponent().getClassName());
    }
    \end{lstlisting}
A través del método \textit{performClick()} es posible simular la lógica del botón, tal como si un usuario real lo hubiese presionado. Esto se realiza dos veces, ya que se tienen que simular dos clicks a dos botones distintos. El último de los click es el que se encarga de abrir la pantalla de Login, por lo que se obtiene el Intent creado por este click a través del método \textit{peekNextStartedActivity()}, para luego verifica a través del método \textit{assertEquals} que la \textit{Activity} que se inició corresponda a \textit{LoginActivity}.

Al ejecutar los tests, se genera un reporte en HTML, que se ubica en la raíz del proyecto, en \textit{./build/test-report/index.html}. En este reporte se detalla la cantidad total de test ejecutados y el tiempo que se demoraron, como también los test que fallaron y la razón.

\subsection{Robotium}
Se implementó Robotium, en vez de Espresso, principalmente porque existe mayor documentación y porque cuenta con soporte para gradle de forma oficial, por lo que la integración con Android Studio es menos compleja. Además lleva más tiempo de desarrollo y es una herramienta bastante madura.

Para agregar Robotium a un proyecto configurado con Gradle es necesario agregar esta línea al archivo \textit{build.gradle} del proyecto:
\begin{lstlisting}
dependencies {
  androidTestCompile 'com.jayway.android.robotium:robotium-solo:4.3'
}
\end{lstlisting}
El test que se realizó es similar al realizado a través de Robolectric, aunque ahora de forma instrumental, es decir ejecutándolo directamente en el dispositivo. Para ello se ha creado la clase RobotiumTest, la cual consiste en lo siguiente:
\begin{lstlisting}
public class RobotiumTest extends ActivityInstrumentationTestCase2 {
    private Solo solo;
    public RobotiumTest() {
        super(SeahorseStartActivity.class);
    }

    public void setUp() throws Exception {
        super.setUp();
        solo = new Solo(getInstrumentation(), getActivity());
    }

    public void testRobotium()  throws Exception {

        solo.assertCurrentActivity("SeahorseStartActivity Never Loaded", SeahorseStartActivity.class);
        solo.clickOnText(getActivity().getString(R.string.LOGIN));
        solo.waitForText(getActivity().getString(R.string.SIGN_IN_WITH_EMAIL));
        solo.clickOnText(getActivity().getString(R.string.SIGN_IN_WITH_EMAIL));
        solo.assertCurrentActivity("LoginActivity Never Loaded", LoginActivity.class);
        solo.takeScreenshot();
    }
\end{lstlisting}
La clase \textit{Solo} es la principal para desarrollar tests con Robotium. En el método \textit{setup()} se crea una referencia de \textit{Solo} a partir de la \textit{Activity} actual.

En el método \textit{testRobotium()} es donde se lleva a cabo el test. Como se puede ver, todo se realiza a través de la clase \textit{Solo}. Con ella se corrobora en un principio si la \textit{Activity} actual corresponde a \textit{SeahorseStartActivity}, luego se hace un click en el texto que dice ``Log In''. Debido a que existe una animación para mostrar el menú, se recurre al método \textit{waitForText} para esperar que la animación termine y luego presionar este botón. Finalmente se presiona el texto ``Sign in with email'' y se comprueba que la nueva \textit{Activity} corresponda a \textit{LoginActivity}. Todo este proceso, al ser ejecutado en un dispositivo real, demora 5.69 segundos, lo cual no es mucho, pero si se toma en cuenta que dentro de un proyecto se puede tener una gran cantidad de tests, entonces sí puede decirse que es un tiempo considerable. Debido a esto, es importante decidir de forma sabia, qué cosas son realmente necesarias testear de manera instrumental.

%\subsection{Espresso} 
%Para la implementación de Espresso, uno de los mayores problemas es que no cuenta oficialmente con soporte para gradle, por lo que se utilizó la biblioteca Double Espresso \cite{58}, que no cambia en nada el código original y simplemente le agrega este soporte. Las dependencias agregadas a gradle son:
%\begin{lstlisting}
%dependencies {
%  ...
%  androidTestCompile 'com.jakewharton.espresso:espresso:1.1-r3'
%  androidTestCompile 'com.jakewharton.espresso:espresso-support-v4:1.1-r3'
%}
%\end{lstlisting}
%A diferencia de Robolectric, Espresso se especializa en los test relacionados con la interfaz de la aplicación. 
\subsection{Spoon}
Spoon es una herramienta que intenta simplificar la tarea de realizar tests de forma distribuida. Es posible ejecutar los mismos tests escritos con Robotium en múltiples dispositivos simultáneamente. Una vez que todos los tests se han completado, un resumen es presentado con información detalla sobre cada dispositivo y cada test en un archivo HTML.

Es necesario agregar dos archivos al proyecto, uno es \textit{spoon-runner} que permite la ejecución simultánea, y el otro es \textit{spoon-client} que se encarga de obtener screenshots de cada uno de los dispositivos, para luego presentarlos en el resumen general.

Para realizar el testing de forma distribuida fue usado un dispositivo Samsung Galaxy S4 y dos emuladores. Debido a que los emuladores provistos por Android son demasiados lentos se usaron los de Genymotion \cite{64}. Ellos ofrecen cerca de 20 emuladores con las simulaciones de distintos dispositivos de forma gratuita. En este caso se usaron los emuladores de un Nexus 4 con Android 4.2.2 y un HTC One con 4.2.2.

El test que se realizó consistía en corroborar que en la pantalla de registro, al completar los datos y dejar uno en blanco, si se presiona el botón ``SIGN UP'', debe aparecer un ícono en el campo vacío, indicando que se necesita completar toda la información. Para ello se utilizó Robotium junto con Spoon, el primero para poder interactuar con la UI, mientras que Spoon se utilizó para obtener los screenshots de los tres dispositivos durante todo el proceso. El código a continuación muestra el uso de Spoon, a través del método \textit{Spoon.screenshot}:
\begin{lstlisting}
    Spoon.screenshot(getActivity(), "RegisterActivity");
    solo.assertCurrentActivity("SeahorseStartActivity Never Loaded", RegisterActivity.class);
    solo.enterText((EditText) solo.getView(R.id.editLastNameRegister), "Oyarzun");
    solo.enterText((EditText) solo.getView(R.id.editEmailRegister), "c.oyarzun@gmail.com");
    solo.enterText((EditText) solo.getView(R.id.editPasswordRegister), "123456");
    Spoon.screenshot(getActivity(), "RegisterActivityWithInfo");
    solo.clickOnText(getActivity().getString(R.string.SIGN_UP).toUpperCase());
    Spoon.screenshot(getActivity(), "ShowMissingField");
\end{lstlisting}
Una vez que el test ya está listo, es necesario ejecutar por línea de comandos lo siguiente:
\begin{lstlisting}
   cristopher$ java -jar spoon-runner-1.1.1-jar-with-dependencies.jar --apk ../PhotoApp/build/outputs/apk/PhotoApp-debug.apk --test-apk ../PhotoApp/build/outputs/apk/PhotoApp-debug-test-unaligned.apk --sdk ../../../Downloads/adt-bundle-mac-x86_64/sdk/
\end{lstlisting}
Los parámetros que se agregan son: el APK, el APK del test y la ruta del SDK. Después de unos segundos se genera una carpeta con el nombre \textit{spoon-out} que contiene los resultados de los tests en cada uno de los dispositivos. 

En la figura \ref{fig:Fig24} se pueden ver los resultados obtenidos en el emulador de Genymotion Nexus 4, en el dispositivo Samsung S4 y en el emulador Genymotion HTC One. Todos los test funcionaron de forma correcta, aunque en la última pantalla, si bien se muestra el ícono indicando que el campo está vacío, éste debería estar acompañado de un diálogo con un texto con el mensaje ``This field is required'', por lo que se puede ver que Spoon no es capaz de capturar los diálogos que se muestran sobre la \textit{Activity} testeada.

\begin{figure}
\centering
      \includegraphics[width=16cm]{Imagenes/testing_spoon}
\caption{Resultados del test ejecutado a través de Spoon. Fuente: Elaboración Propia}
\label{fig:Fig24}
\end{figure}
\subsection{uiautomatorviewer}
Esta es una herramienta de apoyo, que puede servir para personas que están involucradas en el desarrollo de un proyecto móvil, pero que no son desarrolladores. Se puede obtener información muy detallada sobre el árbol jerárquico de vistas y de cada uno de sus elementos. A través de esta información es posible planear diferentes tipos de tests.\\

En la figura \ref{fig:Fig19} se puede apreciar que a la izquierda se tiene una screenshot de la aplicación, y al lado derecho se muestra el árbol jerárquico de vistas de la aplicación. Además el desarrollador puede presionar sobre los elementos del screenshot y obtener información sobre esa vista, tales como la clase, si la vista tiene habilitado el scroll, si la vista se le puede hacer click, entre otras cosas.

\begin{figure}[h!]
\centering
      \includegraphics[width=15cm]{Imagenes/testing_uiautomatorview}
\caption{Vista de la herramienta uiautomatorviewer en una aplicación. Fuente: Elaboración Propia}
\label{fig:Fig19}
\end{figure}

\subsection{Monkey}
Esta herramienta es principalmente usada para realizar casos de testing de estrés. Esto quiere decir que la aplicación es deliberadamente sometida a una gran cantidad de eventos para determinar la estabilidad y el manejo de errores. Los eventos generados consistirán en acciones que podría realizar un usuario normal, como clicks, toques, o gestos, pero en una cantidad muy elevada.\\

Por ejemplo, el siguiente comando enviará 2000 eventos aleatorios a la aplicación con el nombre de paquete \textit{co.seahorse.android}:\\

\begin{lstlisting}
adb shell monkey -p co.seahorse.android -v 2000
\end{lstlisting}

\section{Implementación de Herramientas de Distribución}
\subsection{HockeyApp}
Antes de HockeyApp, en Seahorse se usaba TestFlight \cite{59}, pero ellos dejaron de dar soporte a Android en Marzo de este año \cite{60} ya que fueron comprados por Apple, por lo que fue necesario migrar a otro servicio. HockeyApp cumplía con prácticamente todas las necesidades que entregaba TestFlight, siendo una de ellas el soporte para  aplicaciones tanto Android como iOS. 

Actualmente se pagan 10 dólares por el servicio, de forma mensual, lo que corresponde al plan más económico ofrecido por HockeyApp, que permite tener hasta 5 aplicaciones distintas en la plataforma con una cantidad ilimitada de usuarios.

Para distribuir las versiones, la primera vez es necesario agregar información básica como el nombre de la aplicación y el nombre del paquete. Luego se sube el APK de la aplicación y se invita a las personas que el desarrollador quiere que se conviertan en usuarios de prueba de esta versión. Cada vez que se sube una versión nueva, es posible notificar a los usuarios que ya cuentan con una versión anterior para que la actualicen. Además, es posible invitar a nuevas personas en cualquier momento. 

El desarrollador cuenta con información básica de los testers, como el modelo y dispositivo con el que cuenta, y también es posible saber si es que ya tienen la última versión.

En la figura \ref{fig:Fig22} se puede ver la vista que tiene el desarrollador sobre una versión beta de Seahorse. La acciones más frecuente están en la parte superior, teniendo opciones para subir una nueva versión de la misma aplicación, invitar más usuarios o cambiar información básica de la aplicación. En la parte inferior es posible ver la lista de todas las últimas versiones que se han enviado de esa aplicación, con información como el peso de la aplicación, cuándo fue subida esa actualización y la cantidad de descargas que se han tenido. En Seahorse no está implementado el SDK de HockeyApp para la recepción de reporte de crashes, ya que se usa Crittercism, que entrega información más avanzada. Por último, sobre las acciones más frecuente hay un menú que ofrece la opción de ver todas las versiones que ha tenido la beta, la lista de usuarios que tienen acceso a la beta y el posible feedback que han entregado cada uno de ellos.
\begin{figure}
\centering
      \includegraphics[width=15cm]{Imagenes/distribution_hockeyapp}
\caption{Vista de una aplicación beta de Seahorse en HockeyApp. Fuente: Elaboración Propia}
\label{fig:Fig22}
\end{figure}
%Para su implementación es necesario crearse una cuenta dentro del sitio ....crear la app, subir apk, invitar gente al apk, dps de cada actualizacion aparece la lista de personas para notificarla, en la misma plataforma se puede ver el feedback que dan los usuarios.

\subsection{UserTesting}
UserTesting es la plataforma usada en Seahorse para lanzar versiones beta y recibir feedback de usuarios de prueba a través de videos. Esta herramienta es usada por grandes empresas como Google, Apple, Microsoft, Twitter, Facebook y  Yahoo, para la distribución y testing de versiones de prueba de sitios web, aplicaciones de escritorios y aplicaciones móviles. El servicio funciona a través de la compra de créditos, en donde por ejemplo, 1000 dólares otorgan al desarrollador 20 créditos. Cada uno de estos créditos sirve para realizar un test con un usuario, aunque también es posible realizar un mismo test a más de un usuario, pero en definitiva, por cada usuario que realice un test, un crédito es consumido. Debido al elevado valor de cada crédito, el desarrollador debe tener claro qué es lo que quiere testear dentro de la aplicación y cuáles son los resultados que espera.

En Seahorse se usa UserTesting al momento de implementar nuevas características en la aplicación, para ver temas de usabilidad y para corroborar que el usuario entiende de forma intuitiva lo implementado. Además sirve para encontrar posibles errores en otros dispositivos, ya que debido a la fragmentación existente en Android es prácticamente imposible saber cómo una aplicación se ve en cada uno de los dispositivos existentes.

Para la creación de un test los pasos son los siguientes:
\begin{itemize}
\item Seleccionar si la aplicación móvil es de Android o iOS

\item Agregar instrucciones de cómo instalar la aplicación y una breve descripción para que el usuario tenga una idea de lo que va a testear.

\item Agregar una serie de tareas que el usuario debe ir realizando. También se pueden incluir preguntas durante el proceso, para saber si la tarea solicitada fue complicada, o simplemente para saber qué piensa el usuario sobre esa tarea.

\item Agregar un cuestionario final con preguntas más generales sobre la aplicación y el proceso completo.

\item Por último es posible solicitar algunas características demográficas como el rango de edad, el país, el género, la experiencia con aplicaciones móviles, y otras restricciones como versión de Android mayor a 4.0, o que el usuario cuente con fotos en su galería.
\end{itemize}

Cuando en Seahorse se agregó el registro de usuarios a través de Facebook y de Google+, se llevó a cabo la distribución y testing a través de esta plataforma. Esto permitió corroborar que esta nueva característica, al igual que otras, funcionaban correctamente. Fue necesario hacer en total unos 8 tests, ya que en cada iteración se usaban 4 créditos, 2 para comprobar que el registro a través de Facebook funcionaba bien, y otros 2 para comprobar lo mismo, pero a través de Google+. Los tests a través de Facebook funcionaron correctamente, pero con Google+ existieron dificultades, ya que uno de los usuarios no pudo realizar el registro. Debido a esto, después de realizar algunas correcciones se llevaron a cabo nuevos tests, con los que se obtuvieron resultados positivos. Tal como se mencionó antes, es necesario aprovechar cada uno de los tests, por lo que además de testear el registro de los usuarios, también se solicitaron otras tareas, como importar albums de otras plataformas, sincronizar la cámara del dispositivo con Seahorse, invitar a otros usuarios a la aplicación, entre otras cosas.

Cada uno de los videos entregó información valiosa sobre la usabilidad dentro de la aplicación, y permitió verificar la UI en 8 dispositivos distintos, algunos con una pantalla muy pequeña. Si bien, la cantidad de tareas que se pueden solicitar a los usuarios no tiene límite, los tests deberían durar alrededor de 15 minutos, ya que el sitio les paga a los usuarios por 15 minutos de video. Esto no quiere decir que si el test dura más de ese tiempo, no va a hacer válido, pero va a depender más de la voluntad del tester si desea seguir grabando 20 o 25 minutos. El usuario va relatando todo el proceso, desde la instalación de la aplicación, hasta el cuestionario final.

\section{Implementación de Herramientas de Reportes de Crashes}
\subsection{Crittercism}
Crittercism ha sido la plataforma escogida para la recepción de crashes, principalmente por el nivel de detalle presente en sus reportes. Además el valor que se paga mensualmente es bastante accesible para cualquier empresa del rubro. Actualmente dentro de Seahorse, se pagan 24 dólares mensuales por este servicio, lo que da acceso a reportes muy detallados que permiten reparar de forma rápida cada crash. 

Crittercism ha permitido disminuir la tasa de crashes y ofrece variadas estadísticas para ver información sobre los dispositivos en los que existen más crashes, el sistema operativo en que ocurren más crashes o la versión en la que ocurrieron más crashes. Después del lanzamiento de cada actualización se reparan una gran cantidad de bugs, pero aparecen nuevos crashes, lo que es inherente al proceso de desarrollo de software, ya que se incluye nuevo código, pero con esta herramienta es posible contar con información muy detallada, facilitando en gran medida la tarea de los desarrolladores.

La instalación es bastante simple \cite{31}. Para agregar Crittercism a un proyecto configurado con Gradle es necesario agregar esta línea al archivo \textit{build.gradle} del proyecto:
\begin{lstlisting}
compile 'com.crittercism:crittercism-android-agent:+'
\end{lstlisting}
Luego se deben agregar estos permisos en el Android Manifest del proyecto: 
\begin{lstlisting}
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.READ_LOGS"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
<uses-permission android:name="android.permission.GET_TASKS"/>
\end{lstlisting}
El primer permiso es necesario para poder acceder a Internet y poder enviar los reportes. El segundo es necesario para poder obtener la información de los stack trace del usuario, y ahi saber en qué línea de código ha ocurrido el error. El tercero es para obtener información sobre el estado de la red, por ejemplo, para saber si el usuario está conectado a Wi-Fi o a través de un carrier. El último permiso sirve para acceder a la información de las últimas dos \textit{Activities} ejecutadas, lo que permite saber en qué pantalla ocurrió el crash.

Una vez que los permisos ya están entregados, se debe inicializar Crittercism. Esto se hace únicamente una vez por aplicación, por lo que se debe hacer en la primera \textit{Activity} que se ejecuta dentro de la aplicación. Para iniciar Crittercism se escribe la siguiente línea en el onCreate:
\begin{lstlisting}
Crittercism.initialize(getApplicationContext(), "CRITTERCISM_APP_ID");
\end{lstlisting}

Ahora ya están implementadas las características básicas, y comenzarán a llegar los reportes al sitio web de Crittercism. También es posible agregar a otros desarrolladores al servicio, para que tengan acceso a la misma información y que todo el equipo reciba los reportes de crashes al correo.

La documentación con la que cuenta es excelente para entender los alcances y todas las cosas que se pueden hacer a través de Crittercism. Por ejemplo, es posible recibir las excepciones que ocurren dentro de la aplicación. Esto se realiza agregando las siguientes líneas en la excepción que se desea recibir:
\begin{lstlisting}
try {
    throw new Exception("Aquí ocurre una excepción");
} catch (Exception exception) {
    Crittercism.logHandledException(exception);
}
\end{lstlisting}

A través de los gráficos de la figura \ref{fig:Fig23} es posible dimensionar la utilidad de contar con una herramienta como Crittercism. El gráfico de la izquierda indica la cantidad de reportes de crashes recibidos por distintas versiones de la aplicación durante el mes de Enero. El gráfico de la derecha indica la cantidad de usuarios que han sido afectados por al menos un crash durante ese mismo período. A través de estos gráficos es posible ver que la versión 0.8.8 de color amarillo, fue lanzada el día 9 de Enero y rápidamente comenzaron a llegar una gran cantidad de reportes de crashes, alcanzando la cifra de 173 crashes y afectando a más de 100 usuarios. Debido a ello, al día siguiente se lanzó la versión 0.8.8.1 de color verde, la cual se encargó de arreglar el error introducido en la versión previa y reduciendo este número en gran medida, con sólo 35 crashes y afectando a 20 usuarios. Si esta herramienta, probablemente habrían transcurrido más días con el mismo problema, afectando a muchos más usuarios. 
\begin{figure}
\centering
      \includegraphics[width=14cm]{Imagenes/crash_report_crittercism_graphs}
\caption{Gráficos que entrega Crittercism sobre cantidad de crashes y usuarios afectados en un periodo de un mes. Fuente: Elaboración Propia}
\label{fig:Fig23}
\end{figure}

%\subsection{Google Analytics}
%Google Analytics ha sido implementada, aunque no por sus reportes de crashes, sino que para el tracking de eventos y performance.
%Para su implementación es necesario descarga desde el sitio de Google Analytics \cite{33} la versión 3 de su SDK. Una vez descargado el SDK, es necesario incluirlo al proyecto y dar los siguientes permisos en el archivo Android Manifest:
%\begin{lstlisting}
%<uses-permission android:name="android.permission.INTERNET"/>
%<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
%\end{lstlisting}
%Para implementarlo a través de código es necesario agregar estas líneas en cada una de las \textit{Activities} de las cuáles se desee obtener información:
%\begin{lstlisting}
%@Override
%  public void onStart() {
%    super.onStart();
%    ... // El resto del código de onStart()
%    EasyTracker.getInstance(this).activityStart(this);  // Agregar este método
%  }

%  @Override
%  public void onStop() {
%    super.onStop();
%    ... // El resto del código de onStop()
%    EasyTracker.getInstance(this).activityStop(this);  // Agregar este método
%  }
%\end{lstlisting}
% ---------------------------------------------------------------------------------------------------------------